# 多机调度问题

## 题目

将一组任务（jobs）分配给多台机器（machines），​​最小化所有机器的最大完成时间（makespan）
- 每台机器一次只能处理一个任务。
- 每个任务必须完整地在某一台机器上执行，不可拆分。
- 所有任务在时间0时刻均可开始。

示例​​

​​任务时间​​：[3,5,2,6,4,7,1]（共7个任务）

​​机器数量​​：3台

​​一种可能的分配​​：

机器1：7（时间1） + 6（时间6） → 完成时间 ​​7​​

机器2：5（时间5） + 4（时间4） → 完成时间 ​​9​​

机器3：3（时间3） + 2（时间2） + 1（时间1） → 完成时间 ​​6​​

​​makespan = 9​​（注：此方案可能不是最优解）

就是把m个数字分成n组，最大的那一组的和要最小。

## 解法1 原始回溯

暴力回溯，每次枚举一个任务放到第几个机器上面。
```python
import copy


tasks = [1, 2, 3, 4, 5, 6, 7, 8]
n = len(tasks)
m = 3  # machine

groups = [[] for _ in range(m)]
groups_sum = [0] * m

ans = 1e12
ans_case = None


def dfs(i: int):
    global ans, ans_case
    if i == n:
        if max(groups_sum) < ans:
            ans_case = copy.deepcopy(groups)
            ans = max(groups_sum)
        return
    for j in range(m):
        t = tasks[i]
        groups[j].append(t)
        groups_sum[j] += t
        dfs(i + 1)
        groups[j].pop()
        groups_sum[j] -= t
    return


dfs(0)

print(ans_case, ans)
```

## 分支限界减枝

## 贪心（快速求次优解）

## 动态规划
